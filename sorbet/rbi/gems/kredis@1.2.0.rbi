# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kredis` gem.
# Please instead update this file by running `bin/tapioca gem kredis`.

module Kredis
  include ::Kredis::Types
  include ::Kredis::TypeCasting
  include ::Kredis::Namespace
  include ::Kredis::Connections
  extend ::Kredis::Types
  extend ::Kredis::TypeCasting
  extend ::Kredis::Namespace
  extend ::Kredis::Connections
  extend ::Kredis

  def instrument(channel, **options, &block); end
  def logger; end
  def logger=(val); end
  def redis(config: T.unsafe(nil)); end

  class << self
    def logger; end
    def logger=(val); end
  end
end

module Kredis::Attributes
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Kredis::Attributes::ClassMethods

  private

  def enrich_after_change_with_record_access(type, original_after_change); end
  def extract_kredis_id; end
  def kredis_key_evaluated(key); end
  def kredis_key_for_attribute(name); end
end

module Kredis::Attributes::ClassMethods
  def kredis_boolean(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_counter(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_datetime(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_decimal(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_enum(name, values:, default:, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_flag(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_float(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_hash(name, key: T.unsafe(nil), typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_integer(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_json(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_list(name, key: T.unsafe(nil), typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_proxy(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_set(name, key: T.unsafe(nil), typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_slot(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_slots(name, available:, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def kredis_string(name, key: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def kredis_unique_list(name, limit: T.unsafe(nil), key: T.unsafe(nil), typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end

  private

  def kredis_connection_with(method, name, key, **options); end
end

module Kredis::Connections
  def clear_all; end
  def configurator; end
  def configurator=(val); end
  def configured_for(name); end
  def connections; end
  def connections=(val); end
  def connector; end
  def connector=(val); end

  class << self
    def configurator; end
    def configurator=(val); end
    def connections; end
    def connections=(val); end
    def connector; end
    def connector=(val); end
  end
end

class Kredis::LogSubscriber < ::ActiveSupport::LogSubscriber
  def meta(event); end
  def migration(event); end
  def proxy(event); end

  private

  def formatted_in(color, event, type: T.unsafe(nil)); end
end

class Kredis::Migration
  # @return [Migration] a new instance of Migration
  def initialize(config = T.unsafe(nil)); end

  def delete_all(key_pattern); end
  def migrate(from:, to:, pipeline: T.unsafe(nil)); end
  def migrate_all(key_pattern); end

  private

  def each_key_batch_matching(key_pattern, &block); end
  def log_migration(message, &block); end

  class << self
    def delete_all(*_arg0, **_arg1, &_arg2); end
    def migrate(*_arg0, **_arg1, &_arg2); end
    def migrate_all(*_arg0, **_arg1, &_arg2); end
  end
end

Kredis::Migration::SCAN_BATCH_SIZE = T.let(T.unsafe(nil), Integer)

module Kredis::Namespace
  def namespace; end
  def namespace=(namespace); end
  def namespaced_key(key); end
end

class Kredis::Railtie < ::Rails::Railtie; end
module Kredis::Type; end

class Kredis::Type::DateTime < ::ActiveModel::Type::DateTime
  def cast_value(value); end
  def serialize(value); end
end

class Kredis::Type::Json < ::ActiveModel::Type::Value
  def cast_value(value); end
  def serialize(value); end
  def type; end
end

module Kredis::TypeCasting
  # @raise [InvalidType]
  def string_to_type(value, type); end

  def strings_to_types(values, type); end

  # @raise [InvalidType]
  def type_to_string(value, type); end

  def types_to_strings(values, type); end
end

class Kredis::TypeCasting::InvalidType < ::StandardError; end
Kredis::TypeCasting::TYPES = T.let(T.unsafe(nil), Hash)

module Kredis::Types
  def boolean(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def counter(key, expires_in: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def cycle(key, values:, expires_in: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def datetime(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def decimal(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def enum(key, values:, default:, config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def flag(key, config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def float(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def hash(key, typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def integer(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def json(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def list(key, typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def proxy(key, config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def scalar(key, typed: T.unsafe(nil), default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def set(key, typed: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def slot(key, config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def slots(key, available:, config: T.unsafe(nil), after_change: T.unsafe(nil)); end
  def string(key, default: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil), expires_in: T.unsafe(nil)); end
  def unique_list(key, typed: T.unsafe(nil), limit: T.unsafe(nil), config: T.unsafe(nil), after_change: T.unsafe(nil)); end

  private

  def type_from(type_klass, config, key, after_change: T.unsafe(nil), **options); end
end

class Kredis::Types::CallbacksProxy
  # @return [CallbacksProxy] a new instance of CallbacksProxy
  def initialize(type, callback); end

  def method_missing(method, *args, **kwargs, &block); end
  def to_s(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute type.
  def type; end

  private

  def invoke_suitable_after_change_callback_for(method); end
end

Kredis::Types::CallbacksProxy::AFTER_CHANGE_OPERATIONS = T.let(T.unsafe(nil), Hash)

class Kredis::Types::Counter < ::Kredis::Types::Proxying
  def decrby(*_arg0, **_arg1, &_arg2); end
  def decrement(by: T.unsafe(nil)); end
  def del(*_arg0, **_arg1, &_arg2); end
  def exists?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute expires_in.
  def expires_in; end

  # Sets the attribute expires_in
  #
  # @param value the value to set the attribute expires_in to.
  def expires_in=(_arg0); end

  def get(*_arg0, **_arg1, &_arg2); end
  def incrby(*_arg0, **_arg1, &_arg2); end
  def increment(by: T.unsafe(nil)); end
  def multi(*_arg0, **_arg1, &_arg2); end
  def reset; end
  def set(*_arg0, **_arg1, &_arg2); end
  def value; end
end

class Kredis::Types::Cycle < ::Kredis::Types::Counter
  def index; end
  def next; end
  def value; end

  # Returns the value of attribute values.
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  def values=(_arg0); end
end

class Kredis::Types::Enum < ::Kredis::Types::Proxying
  # @return [Enum] a new instance of Enum
  def initialize(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute default.
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  def default=(_arg0); end

  def del(*_arg0, **_arg1, &_arg2); end
  def exists?(*_arg0, **_arg1, &_arg2); end
  def get(*_arg0, **_arg1, &_arg2); end
  def reset; end
  def set(*_arg0, **_arg1, &_arg2); end
  def value; end
  def value=(value); end

  # Returns the value of attribute values.
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  def values=(_arg0); end

  private

  def define_predicates_for_values; end
end

class Kredis::Types::Flag < ::Kredis::Types::Proxying
  def del(*_arg0, **_arg1, &_arg2); end
  def exists?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute expires_in.
  def expires_in; end

  # Sets the attribute expires_in
  #
  # @param value the value to set the attribute expires_in to.
  def expires_in=(_arg0); end

  def mark(expires_in: T.unsafe(nil), force: T.unsafe(nil)); end

  # @return [Boolean]
  def marked?; end

  def remove; end
  def set(*_arg0, **_arg1, &_arg2); end
end

class Kredis::Types::Hash < ::Kredis::Types::Proxying
  def [](key); end
  def []=(key, value); end
  def clear; end
  def del(*_arg0, **_arg1, &_arg2); end
  def delete(*keys); end
  def entries; end
  def exists?(*_arg0, **_arg1, &_arg2); end
  def hdel(*_arg0, **_arg1, &_arg2); end
  def hget(*_arg0, **_arg1, &_arg2); end
  def hgetall(*_arg0, **_arg1, &_arg2); end
  def hkeys(*_arg0, **_arg1, &_arg2); end
  def hmget(*_arg0, **_arg1, &_arg2); end
  def hset(*_arg0, **_arg1, &_arg2); end
  def hvals(*_arg0, **_arg1, &_arg2); end
  def keys; end
  def remove; end
  def to_h; end

  # Returns the value of attribute typed.
  def typed; end

  # Sets the attribute typed
  #
  # @param value the value to set the attribute typed to.
  def typed=(_arg0); end

  def update(**entries); end
  def values; end
  def values_at(*keys); end
end

class Kredis::Types::List < ::Kredis::Types::Proxying
  def <<(*elements, pipeline: T.unsafe(nil)); end
  def append(*elements, pipeline: T.unsafe(nil)); end
  def clear; end
  def del(*_arg0, **_arg1, &_arg2); end
  def elements; end
  def exists?(*_arg0, **_arg1, &_arg2); end
  def lpush(*_arg0, **_arg1, &_arg2); end
  def lrange(*_arg0, **_arg1, &_arg2); end
  def lrem(*_arg0, **_arg1, &_arg2); end
  def prepend(*elements, pipeline: T.unsafe(nil)); end
  def remove(*elements, pipeline: T.unsafe(nil)); end
  def rpush(*_arg0, **_arg1, &_arg2); end
  def to_a; end

  # Returns the value of attribute typed.
  def typed; end

  # Sets the attribute typed
  #
  # @param value the value to set the attribute typed to.
  def typed=(_arg0); end
end

class Kredis::Types::Proxy
  include ::Kredis::Types::Proxy::Failsafe

  # @return [Proxy] a new instance of Proxy
  def initialize(redis, key, **options); end

  # Returns the value of attribute key.
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  def key=(_arg0); end

  def method_missing(method, *args, **kwargs); end
  def multi(&block); end

  # Returns the value of attribute redis.
  def redis; end

  # Sets the attribute redis
  #
  # @param value the value to set the attribute redis to.
  def redis=(_arg0); end

  private

  def log_message(method, *args, **kwargs); end
end

module Kredis::Types::Proxy::Failsafe
  def initialize(*_arg0); end

  def failsafe; end
  def suppress_failsafe_with(returning: T.unsafe(nil)); end

  private

  # @return [Boolean]
  def fail_safe_suppressed?; end
end

class Kredis::Types::Proxying
  # @return [Proxying] a new instance of Proxying
  def initialize(redis, key, **options); end

  def failsafe(returning: T.unsafe(nil), &block); end

  # Returns the value of attribute key.
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  def key=(_arg0); end

  # Returns the value of attribute proxy.
  def proxy; end

  # Sets the attribute proxy
  #
  # @param value the value to set the attribute proxy to.
  def proxy=(_arg0); end

  # Returns the value of attribute redis.
  def redis; end

  # Sets the attribute redis
  #
  # @param value the value to set the attribute redis to.
  def redis=(_arg0); end

  def string_to_type(*_arg0, **_arg1, &_arg2); end
  def strings_to_types(*_arg0, **_arg1, &_arg2); end
  def type_to_string(*_arg0, **_arg1, &_arg2); end
  def types_to_strings(*_arg0, **_arg1, &_arg2); end

  class << self
    def proxying(*commands); end
  end
end

class Kredis::Types::Scalar < ::Kredis::Types::Proxying
  # @return [Boolean]
  def assigned?; end

  def clear; end

  # Returns the value of attribute default.
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  def default=(_arg0); end

  def del(*_arg0, **_arg1, &_arg2); end
  def exists?(*_arg0, **_arg1, &_arg2); end
  def expire(*_arg0, **_arg1, &_arg2); end
  def expire_at(datetime); end
  def expire_in(seconds); end
  def expireat(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute expires_in.
  def expires_in; end

  # Sets the attribute expires_in
  #
  # @param value the value to set the attribute expires_in to.
  def expires_in=(_arg0); end

  def get(*_arg0, **_arg1, &_arg2); end
  def set(*_arg0, **_arg1, &_arg2); end
  def to_s; end

  # Returns the value of attribute typed.
  def typed; end

  # Sets the attribute typed
  #
  # @param value the value to set the attribute typed to.
  def typed=(_arg0); end

  def value; end
  def value=(value); end
end

class Kredis::Types::Set < ::Kredis::Types::Proxying
  def <<(*members, pipeline: T.unsafe(nil)); end
  def add(*members, pipeline: T.unsafe(nil)); end
  def clear; end
  def del(*_arg0, **_arg1, &_arg2); end
  def exists?(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  def include?(member); end

  def members; end
  def multi(*_arg0, **_arg1, &_arg2); end
  def remove(*members, pipeline: T.unsafe(nil)); end
  def replace(*members); end
  def sadd(*_arg0, **_arg1, &_arg2); end
  def scard(*_arg0, **_arg1, &_arg2); end
  def sismember(*_arg0, **_arg1, &_arg2); end
  def size; end
  def smembers(*_arg0, **_arg1, &_arg2); end
  def spop(*_arg0, **_arg1, &_arg2); end
  def srem(*_arg0, **_arg1, &_arg2); end
  def take; end
  def to_a; end

  # Returns the value of attribute typed.
  def typed; end

  # Sets the attribute typed
  #
  # @param value the value to set the attribute typed to.
  def typed=(_arg0); end
end

class Kredis::Types::Slots < ::Kredis::Types::Proxying
  # Returns the value of attribute available.
  def available; end

  # Sets the attribute available
  #
  # @param value the value to set the attribute available to.
  def available=(_arg0); end

  # @return [Boolean]
  def available?; end

  def decr(*_arg0, **_arg1, &_arg2); end
  def del(*_arg0, **_arg1, &_arg2); end
  def exists?(*_arg0, **_arg1, &_arg2); end
  def get(*_arg0, **_arg1, &_arg2); end
  def incr(*_arg0, **_arg1, &_arg2); end
  def release; end
  def reserve; end
  def reset; end
  def taken; end
end

class Kredis::Types::Slots::NotAvailable < ::StandardError; end

# You'd normally call this a set, but Redis already has another data type for that
class Kredis::Types::UniqueList < ::Kredis::Types::List
  def <<(elements); end
  def append(elements); end
  def exists?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute limit.
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  def limit=(_arg0); end

  def ltrim(*_arg0, **_arg1, &_arg2); end
  def multi(*_arg0, **_arg1, &_arg2); end
  def prepend(elements); end

  # Returns the value of attribute typed.
  def typed; end

  # Sets the attribute typed
  #
  # @param value the value to set the attribute typed to.
  def typed=(_arg0); end
end

Kredis::VERSION = T.let(T.unsafe(nil), String)
